// /src/coframe.ts - The final, correct library class

import { toU8 } from "@/lib/prollyUtils";
import { Builder, ByteBuffer } from "flatbuffers";
import { WasmProllyTree, type TreeConfigOptions } from "prolly-wasm";

// The generic constraints now perfectly match the code flatc generates.
type Unpackable<T_Plain> = { unpack(): T_Plain };
type Packable = { pack(builder: Builder): number };

export interface CoframeOptions<T_Plain> {
  /**
   * The static getRootAs...() method from the generated accessor class.
   * This is used for reading.
   * Example: (bb) => User.getRootAsUser(bb)
   */
  getRootAs: (bb: ByteBuffer) => Unpackable<T_Plain>;

  /** The name of the primary key field on your plain object. */
  primaryKey: keyof T_Plain;

  // treeConfig?: TreeConfigOptions;
}

export class Coframe<T_Plain> {
  private readonly getRootAsFn: (bb: ByteBuffer) => Unpackable<T_Plain>;
  private readonly primaryKeyField: keyof T_Plain;
  private readonly tree: WasmProllyTree;

  constructor(options: CoframeOptions<T_Plain>) {
    this.getRootAsFn = options.getRootAs;
    this.primaryKeyField = options.primaryKey;
    this.tree = new WasmProllyTree();
  }

  /**
   * Inserts or replaces an object. The object must have a .pack() method.
   * This aligns with the class generated by `flatc --gen-object-api`.
   */
  async put(data: T_Plain & Packable): Promise<void> {
    const primaryKey = String((data as any)[this.primaryKeyField]);

    const builder = new Builder(1024);
    // The object itself knows how to pack itself into the builder.
    // This is the key insight I was missing.
    const rootOffset = data.pack(builder);
    builder.finish(rootOffset);
    const buffer = builder.asUint8Array();

    await this.tree.insert(toU8(primaryKey), buffer);
  }

  /**
   * Retrieves data and returns it as a plain JavaScript object.
   */
  async get(id: any): Promise<T_Plain | null> {
    const buffer = await this.tree.get(toU8(String(id)));
    if (!buffer) return null;

    const byteBuffer = new ByteBuffer(buffer);
    const accessor = this.getRootAsFn(byteBuffer);

    // The generated unpack() method returns the plain object.
    return accessor.unpack();
  }
}

// The factory function
export function createCoframe<T_Plain>(
  options: CoframeOptions<T_Plain>
): Coframe<T_Plain> {
  return new Coframe<T_Plain>(options);
}
